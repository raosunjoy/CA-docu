import { renderHook, act } from '@testing-library/react'
import { useAuth } from '../useAuth'
import { UserRole } from '@/types'

// Mock fetch globally
const mockFetch = jest.fn()
global.fetch = mockFetch

// Mock crypto
Object.defineProperty(global, 'crypto', {
  value: {
    randomUUID: () => 'test-uuid'
  }
})

// Helper functions

function createMockUser() {
  return {
    id: 'user-123',
    email: 'test@example.com',
    firstName: 'John',
    lastName: 'Doe',
    role: UserRole.ASSOCIATE,
    isActive: true,
    lastLoginAt: null,
    organization: {
      id: 'org-123',
      name: 'Test Org',
      subdomain: 'test'
    },
    permissions: ['read:tasks']
  }
}

function setupSuccessfulAuthResponse(user: ReturnType<typeof createMockUser>) {
  mockFetch.mockResolvedValueOnce({
    ok: true,
    json: async () => ({
      success: true,
      data: user
    })
  })
}

async function waitForAuthCheck() {
  await act(async () => {
    await new Promise(resolve => setTimeout(resolve, 0))
  })
}

describe('useAuth', () => {
  beforeEach(() => {
    mockFetch.mockClear()
  })

  it('should initialize with loading state', () => {
    mockFetch.mockResolvedValueOnce({
      ok: false,
      status: 401
    })

    const { result } = renderHook(() => useAuth())

    expect(result.current.user).toBeNull()
    expect(result.current.loading).toBe(true)
    expect(result.current.error).toBeNull()
    expect(result.current.isAuthenticated).toBe(false)
  })

  it('should handle successful authentication check', async () => {
    const mockUser = createMockUser()
    setupSuccessfulAuthResponse(mockUser)

    const { result } = renderHook(() => useAuth())
    await waitForAuthCheck()

    expect(result.current.user).toEqual(mockUser)
    expect(result.current.loading).toBe(false)
    expect(result.current.isAuthenticated).toBe(true)
  })

  it('should handle login success', async () => {
    setupLoginSuccessMocks()

    const { result } = renderHook(() => useAuth())
    await waitForAuthCheck()

    const loginResult = await performLogin(result)

    expect(loginResult).toEqual({ success: true })
    expect(result.current.user).toBeDefined()
  })

  function setupLoginSuccessMocks() {
    mockFetch
      .mockResolvedValueOnce({ ok: false }) // Initial auth check
      .mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          success: true,
          data: {
            user: {
              id: 'user-123',
              email: 'test@example.com'
            }
          }
        })
      })
  }

  async function performLogin(result: { current: { login: (credentials: { email: string; password: string }) => Promise<unknown> } }) {
    let loginResult
    await act(async () => {
      loginResult = await result.current.login({
        email: 'test@example.com',
        password: 'password123'
      })
    })
    return loginResult
  }

  it('should handle login failure', async () => {
    setupLoginFailureMocks()

    const { result } = renderHook(() => useAuth())
    await waitForAuthCheck()

    const loginResult = await performLoginWithWrongCredentials(result)

    expect(loginResult).toEqual({ 
      success: false, 
      error: 'Invalid credentials' 
    })
    expect(result.current.error).toBe('Invalid credentials')
  })

  function setupLoginFailureMocks() {
    mockFetch
      .mockResolvedValueOnce({ ok: false }) // Initial auth check
      .mockResolvedValueOnce({
        ok: false,
        json: async () => ({
          success: false,
          error: { message: 'Invalid credentials' }
        })
      })
  }

  async function performLoginWithWrongCredentials(result: { current: { login: (credentials: { email: string; password: string }) => Promise<unknown> } }) {
    let loginResult
    await act(async () => {
      loginResult = await result.current.login({
        email: 'test@example.com',
        password: 'wrongpassword'
      })
    })
    return loginResult
  }

  it('should handle register success', async () => {
    setupRegisterSuccessMocks()

    const { result } = renderHook(() => useAuth())
    await waitForAuthCheck()

    const registerResult = await performRegistration(result)

    expect(registerResult).toEqual({ success: true })
    expect(result.current.user).toBeDefined()
  })

  function setupRegisterSuccessMocks() {
    mockFetch
      .mockResolvedValueOnce({ ok: false }) // Initial auth check
      .mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          success: true,
          data: {
            user: {
              id: 'user-123',
              email: 'new@example.com'
            }
          }
        })
      })
  }

  async function performRegistration(result: { current: { register: (data: { email: string; password: string; firstName: string; lastName: string; organizationId: string; role: UserRole }) => Promise<unknown> } }) {
    let registerResult
    await act(async () => {
      registerResult = await result.current.register({
        email: 'new@example.com',
        password: 'Password123!',
        firstName: 'John',
        lastName: 'Doe',
        organizationId: 'org-123',
        role: UserRole.ASSOCIATE
      })
    })
    return registerResult
  }

  it('should handle logout', async () => {
    mockFetch
      .mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          success: true,
          data: { id: 'user-123' }
        })
      }) // Initial auth check
      .mockResolvedValueOnce({ ok: true }) // Logout

    const { result } = renderHook(() => useAuth())

    await act(async () => {
      await new Promise(resolve => setTimeout(resolve, 0))
    })

    let logoutResult
    await act(async () => {
      logoutResult = await result.current.logout()
    })

    expect(logoutResult).toEqual({ success: true })
    expect(result.current.user).toBeNull()
    expect(result.current.isAuthenticated).toBe(false)
  })

  it('should handle network errors', async () => {
    mockFetch
      .mockResolvedValueOnce({ ok: false }) // Initial auth check
      .mockRejectedValueOnce(new Error('Network error'))

    const { result } = renderHook(() => useAuth())

    await act(async () => {
      await new Promise(resolve => setTimeout(resolve, 0))
    })

    let loginResult
    await act(async () => {
      loginResult = await result.current.login({
        email: 'test@example.com',
        password: 'password123'
      })
    })

    expect(loginResult).toEqual({ 
      success: false, 
      error: 'Network error occurred' 
    })
    expect(result.current.error).toBe('Network error occurred')
  })

  it('should clear errors', async () => {
    mockFetch
      .mockResolvedValueOnce({ ok: false }) // Initial auth check
      .mockResolvedValueOnce({
        ok: false,
        json: async () => ({
          success: false,
          error: { message: 'Some error' }
        })
      })

    const { result } = renderHook(() => useAuth())

    await act(async () => {
      await new Promise(resolve => setTimeout(resolve, 0))
    })

    await act(async () => {
      await result.current.login({
        email: 'test@example.com',
        password: 'wrongpassword'
      })
    })

    expect(result.current.error).toBe('Some error')

    act(() => {
      result.current.clearError()
    })

    expect(result.current.error).toBeNull()
  })
})